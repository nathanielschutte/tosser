import os
from pathlib import Path
from typing import Generator, List, Dict, Any, Optional, Iterable, Iterator, Union
from dataclasses import dataclass

from tosser.object import TosserObject
from tosser.rules import TosserRuleSet, TosserRule

class TosserTraverserException(Exception):
    pass


@dataclass
class TosserResult:
    """Result struct generated by Traverser"""

    rows: List[Dict[str, Any]]

    def __iter__(self):
        return iter(self.rows)


class Traverser:
    """Traverse an object and generate TosserResult objects according to rules"""

    def __init__(self, rules: Optional[TosserRuleSet] = None) -> None:
        self._rules: Optional[TosserRuleSet] = rules

    def traverse(self, obj: TosserObject) -> Generator[Any, None, None]:
        """Traverse the object and yield each value"""

        ...


    def traverse_and_capture(self, obj: TosserObject, rules: Optional[TosserRuleSet] = None) -> Generator[TosserResult | None, None, None]:
        """Traverse the object and yield """

        if rules is not None:
            self._rules = rules
        assert self._rules is not None
        rs: TosserRuleSet = self._rules

        root_context: bool = True
        context_identifier: str = '$'
        context_trail: List[str] = []
        matched_rules_gen = rs._next_rules()

        def _inner_traverse(_raw_obj: Dict[str, Any]):
            print(f'[traverse] eval ctx={context_identifier}')

            # Check current context against rules
            matched_rules = next(matched_rules_gen)

            try:
                matched_rules_gen.send((context_identifier, root_context))
            except StopIteration as e:
                print(e)

            yield matched_rules

            # Iterate subobjects
            # yield from self._traverse(...)

        yield from _inner_traverse(obj.data)

        return None
