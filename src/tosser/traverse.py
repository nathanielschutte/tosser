import os
from pathlib import Path
from typing import Generator, List, Dict, Any, Optional, Tuple, Iterator, Union
from dataclasses import dataclass
from enum import Enum

from tosser.object import TosserObject
from tosser.rules import TosserRuleSet, TosserRule


ROOT_ID = '$'


class TosserTraverserException(Exception):
    pass


class TrailTokenType(Enum):
    KEY = 'key'
    INDEX = 'index'


@dataclass
class TrailToken:
    """Traversal trail token is a value and a type"""

    val: str | int
    type: TrailTokenType


@dataclass
class TosserResult:
    """Result struct generated by Traverser"""

    rows: List[Dict[str, Any]]

    def __iter__(self):
        return iter(self.rows)


class Traverser:
    """Traverse an object and generate TosserResult objects according to rules"""

    def __init__(self, rules: Optional[TosserRuleSet] = None) -> None:
        self._rules: Optional[TosserRuleSet] = rules


    def traverse(self, obj: TosserObject) -> Generator[Tuple[List[TrailToken], str, Any], None, None]:
        """Traverse the object and yield each value"""

        data = obj.data

        def _inner_traverse(_data: Any, trail: List[TrailToken]):
            if isinstance(_data, dict):
                for key, obj in _data.items():
                    next_trail = trail.copy()
                    next_trail.append(TrailToken(key, TrailTokenType.KEY))
                    yield from _inner_traverse(obj, next_trail)
            elif isinstance(_data, list):
                for i, obj in enumerate(_data):
                    next_trail = trail.copy()
                    next_trail.append(TrailToken(i, TrailTokenType.INDEX))
                    yield from _inner_traverse(obj, next_trail)
            else:
                yield (trail, trail[-1].val, _data)


        yield from _inner_traverse(data, [TrailToken(ROOT_ID, TrailTokenType.KEY)])

        return None


    def traverse_and_capture(self, obj: TosserObject, rules: Optional[TosserRuleSet] = None) -> Generator[TosserResult | None, None, None]:
        """Traverse the object and yield """

        if rules is not None:
            self._rules = rules
        assert self._rules is not None
        rs: TosserRuleSet = self._rules

        root_context: bool = True
        context_identifier: str = ROOT_ID
        context_trail: List[str] = []
        matched_rules_gen = rs._next_rules()

        def _inner_traverse(_raw_obj: Dict[str, Any]):
            print(f'[traverse] eval ctx={context_identifier}')

            # Check current context against rules
            matched_rules = next(matched_rules_gen)

            try:
                matched_rules_gen.send((context_identifier, root_context))
            except StopIteration as e:
                print(e)

            yield matched_rules

            # Iterate subobjects
            # yield from self._traverse(...)

        yield from _inner_traverse(obj.data)

        return None
    
    
    @staticmethod
    def get_trail_string(trail: List[TrailToken]) -> str:
        """Return a string representation of the trail"""

        return '.'.join(map(lambda t: str(t.val), trail))
